1.3 웹 서비스의 동작 원리 이해하기

■ 웹 서비스는 클라이언트의 요청에 따른 서버의 응답으로 동작.

■ 클라이언트: 서비스를 사용하는 프로그램 또는 컴퓨터
■ 서버: 서비스를 제공하는 프로그램 또는 컴퓨터

■ localhost
내 컴퓨터를 의미

=========================

2장 MVC 패턴 이해와 실습

2.1 뷰 템플릿과 MVC 패턴

스프링 부트 프로젝트를 만들 때 머스테치 라는 도구가 뷰 템플릿을 만드는 도구

2.1.2 MVC 패턴

뷰: 화면을 담당하는 뷰탬플릿
컨트롤러: 클라이언트의 요청에 따라 서버에서 이를 처리하는 역할
모델: 데이터를 관리하는 역할

-> MVC 패턴(Model-View-Controller Pattern)

2.2 MVC 패턴을 활용해 뷰 템플릿 페이지 만들기

2.2.3 모델 추가하기

■ 요약
1. 뷰 페이지 만들기
greetings.mustache

2. 컨트롤러 만들기
FirstController.java

3. 컨트롤러에서 뷰 페이지 반환하기
return "greetings"

4. 뷰 페이지에 변수 삽입하기
{{username}}

5. 컨트롤러에 모델 추가하기
niceToMeetYou(Model model)

6. 모델에서 변수 등록하기
model.addAttribute("username". "홍팍")

2.3 MVC의 역할과 실행 흐름 이해하기

1. FirstController 파일이 컨트롤러임을 선언
2. 클라이언트로부터 "/hi"라는 요청을 받아 접수
3. "/hi" 라는 요청을 받음과 동시에 niceToMeetYou() 메서드를 수행
4. 뷰 템플릿 페이지에서 사용할 변수를 등록하기 위해 모델 객체를 매개변수로 가져온다.
5. 모델에서 사용할 변수를 등록한다. 변수값에 따라 서로 다른 뷰 템플릿 페이지가 출력된다.
6. 메서드를 수행한 결과로 greetings.mustache 파일을 반환한다.
  이때 return문에는 파일 이름만 작성.(return "greetings";).
  그러면 서버가 알아서 templates 디렉터리에 있는 해당 뷰 템플릿 페이지를 찾아 웹 브라우저로 전송.

2.3.2 /bye 페이지의 실행 흐름

2.4 뷰 템플릿 페이지에 레이아웃 적용하기

■ 레이아웃(layout)
: 화면에 요소를 배치하는 일

■ 헤더-푸터 레이아웃(header-footer-layout)
: 기본적인 레이아웃
- 상단의 헤더(header)영억에는 사이트 안내를 위한 내비게이션을 넣고
- 하단의 푸터(footer) 영역에는 사이트 정보를 넣는다.
- 두 영역 사이에는 사용자가 볼 핵심 내용인 콘텐트(content)를 배치

2.4.1 /hi 페이지에 헤더-푸터 레이아웃 적용하기

부트스트랩(https://getbootstrap.com) 활용

2.4.2 /bye 페이지에 헤더-푸터 레이아웃 적용하기

/hi 페이지를 템플릿화 해서 사용
위에는 {{>header}}, 아래는 {{>footer}}

폴더를 지정해서 파일을 만들고
footer.mustache
header.mustache

최종적으로는 
{{>layout/header}}
{{>layouts/footer}}

■ 마무리
1. 뷰 템플릿
: 웹 페이지를 하나의 틀로 만들고 여기에 변수를 삽입해 서로 다른 페이지로 보여 주는 기술

2. MVC 패턴
: 웹 페이지를 화면에 보여주고(View), 클라이언트의 요청을 받아 처리하고(Controller),
데이터를 관리하는(Model) 역할을 영역별로 나누어 하는 기법

3. 뷰 템플릿 생성 위치
src > main > resource > templates 디렉터리에 만든다.
머스테치 뷰 템플릿의 확장자는 .mustache 이다

4. 컨트롤러 생성 위치
src > main > java > 기본 패키지 안에 컨트롤러 패키지를 만든 후 자바 클래스 파일을 생성하는 방식으로 만든다.
확장자는 .java

5. 모델을 통해 변수 등록하는 방법
모델은 컨트롤러의 메서드에서 ㅐ개변수로 받아 온다.
모델에서 변수를 등록할 때는 addAttribute() 메서드를 사용.

6. 헤더-푸터 레이아웃
가장 기본이 되는 레이아웃.

7. 레이아웃 템플릿 생성과 적용
1) 레이아웃 템플릿 파일은 src > main > resource > templates 디렉터리에 만든다.
2) 머스테치 템플릿 파일의 확장자는 .mustache
3) 레이아웃 템플릿을 삽입할 때는 원하는 위치에서 {{>파일경로/파일명}} 형식으로 작성한다.

============================================
Part 2
게시판 CRUD 만들기
============================================

3장 게시판 만들고 새 글 작성하기 Create
3.1 폼 데이터란

■ 폼데이터
: HTML 요소인 <form> 태그에 실려 전송하는 데이터
<form> 태그에 실어 보낸 데이터는 서버의 컨트롤러가 객체에 담아 받는다.
이 객체를 DTO(Data Transfer Object)라고 한다.

DTO로 받은 데이터는 최종적으로 데이터베이스에 저장된다.

============================================
3.2 폼 데이터를 DTO로 받기

3.2.1 입력 폼 만들기
3.2.2 컨트롤러 만들기
3.2.3 폼 데이터 전송하기
3.2.4 폼 데이터 받기
3.2.5 DTO 만들기
  - Data Transfer Object
3.2.6 폼 데이터를 DTO에 담기
3.2.7 입력 폼과 DTO 필드 연결하기

============================================
3.3 DTO를 데이터베이스에 저장하기

3.3.1 데이터베이스와 JPA

■ JPA란
Java Persistence API, 자바 언어로 DB에 명령을 내리는 도구가

■ 엔티티
: 자바 객체를 DB가 이해할 수 있게 만든 것, 이를 기반으로 테이블이 만들어진다

■ 레파지터리
: 엔티티가 DB속 테이블에 저장 및 관리될 수 있게 하는 인터페이스

3.3.2 DTO를 엔티티로 변환하기

3.3.3 리파지터리로 엔티티를 DB에 저장하기

■ CrudRepository 는
JPA에서 제공하는 인터페이스로 이를 상속해 엔티티를 관리(생성, 조회, 수정, 삭제) 할 수 있다.

■ @Autowired
: 스프링 부트에서 제공하는 어노테이션으로
  이를 컨트롤러의 필드에 붙이면 스프링 부트가 만들어 놓은 객체를 가져와 주입한다.
-> 의존성 주입(DI, Dependency Injection)

============================================
3.4 DB 데이터 조회하기

3.4.1 H2 DB 접속하기

■ 마무리
1. 폼 데이터와 <form> 태그
폼 데이터는 <form>태그에 실려 전송되는 데이터를 말한다.
<form> 태그에는 전송할 데이터를 어디에 어떻게 ㅈ보낼지도 설정하는데, 어디에 보낼지는 action 속성으로,
어떻게 보낼지는 method 속성으로 설정한다.

2. DTO
폼 데이터에 실어 보낸 데이터는 서버의 컨트롤러가 객체에 담아 받는데, 이 객체를 DTO(Data Transfer Object) 라고 한다.
DTO로 받은 데이터는 최종적으로 데이터베이스에 저장된다.

============================================
4장 롬복과 리팩터링
4.1 롬복이란

■ 롬복(lombok)
: 코드를 간소화해주는 라이브러리

■ 리팩터링(refactoring)
: 코드의 기능에는 변함이 없이 코드의 구조 또는 성능을 개선하는 작업

============================================
4.2 롬복을 활용해 리팩터링 하기

4.2.1 롬복 설치하기

4.2.2 DTO 리팩터링하기

4.2.3 엔티티 리팩터링하기

4.2.4 컨트롤러에 로그 남기기

■ 마무리

■ @AllArgsConstructor
: 클래스 안쪽의 모든 필드를 매개변수로 하는 생성자를 만드는 어노테이션으로,
이를 사용하면 클래스 내에 별도의 생성자를 만들지 않아도 된다.

@Slf4j
: Simple Logging Facade for Java의 약자로, 로깅할 때 사용한다.
로깅 기능으로 로그를 찍으면 나중에라도 그동안 찍힌 로그를 찾아볼 수 있다.

============================================
5장 게시글 읽기: Read

5.1 데이터 조회 과정

5.2 단일 데이터 조회하기

5.2.1 URL 요청받기

5.2.2 데이터 조회해 출력하기
■ 3단계
  1. id를 조회해 db에서 해당 데이터 가져오기
  2. 가져온 데이터를 모델에 등록하기
  3. 조회한 데이터를 사용자에게 보여주기 위한 뷰 페이지 만들고 반환하기

============================================
5.3 데이터 목록 조회하기

5.3.1 URL 요청받기

5.3.2 데이터 조회해 출력하기
  1. DB에서 모든 Article 데이터 가져오기
  2. 가져온 Article 묶음을 모델에 등록하기
  3. 사용자에게 보여 줄 뷰 페이지 설정하기

범주
List ⊂ Collection ⊂ Iterable  

@PathVariable
URL 요청으로 들어온 전달값을 컨트롤러의 매개변수로 가져오는 어노테이션

■ findById()
JPA의 CrudRepository가 제공하는 메서드,
특정 엔티티의 id값을 기준으로 데이터를 찾아 Optional 타입으로 반환

■ findAll()
JPA의 CrudRepository가 제공하는 메서드,
특정 엔티티를 모두 가져와 Iterable 타입으로 반환

■ {{@article}} {{/article}}
뷰 페이지에서 모델에 등록된 article의 사용범위를 지정할 때 사용하는 머스테치 문법.
범위 내에서 article 데이터를 사용할 수 있다.
등록된 데이터가 복수이면 해당 범위 코드가 반복된다.

■ 반환 데이터 타입 불일치 해결방법
  1) 메서드가 반환하는 데이터 타입을 사용자가 작성한 데이터 타입으로 캐스팅(형변환) 하기
  2) 사용자가 작성한 데이터 타입을 메서드가 반환하는 데이터 타입으로 수정하기
  3) 메서드의 반환 데이터 타입을 원하는 타입으로 오버라이딩하기

============================================
6장 게시판 내 페이지 이동하기

6.1 링크와 리다이렉트란

■ 리다이렉트(redirect)란 클라이언트가 보낸 요청을 마친 후 계속해서 처리할 다음 요청 주소를 재지시

6.2 링크와 리다이렉트를 이용해 페이지 연결하기

6.2.1 새 글 작성 링크 만들기

6.2.2 <입력 페이지> -> <목록 페이지> 돌아가기

6.2.3 <입력 페이지> -> <상세 페이지> 이동하기

6.2.4 <상세 페이지> -> <목록 페이지> 돌아가기

6.2.5 <목록 페이지> -> <상세 페이지> 이동하기

============================================
7장 게시글 수정하기: Update

7.1 데이터 수정 과정
1) <수정 페이지> 만들고 기존 데이터 불러오기
  -1 <상세페이지>에서 [Edit] 버튼을 클릭
  -2 요청을 받은 컨트롤러는 해당 글의 id로 DB에서 데이터를 가져옴
  -3 컨트롤러는 가져온 데이터를 뷰에서 사용할 수 있도록 모델에 등록
  -4 모델에 등록된 데이터를 <수정 페이지>에서 보여줌
      -> 사용자가 내용을 수정할 수 있는 상태
2) 데이터를 수정해 DB에 반영한 후 결과를 볼 수 있게 <상세페이지>로 리다이렉트하기
  -1 폼 데이터(수정 요청 데이터)를 DTO에 담아 컨트롤러에서 받음
  -2 DTO를 엔티티로 변환
  -3 DB에서 기존 데이터를 수정 데이터로 갱신
  -4 수정 데이터를 <상세 페이지>로 리다이렉트

7.2 <수정 페이지> 만들기

7.2.1 <상세 페이지>에 Edit 버튼 만들기

7.2.2 Edit 요청을 받아 데이터 가져오기

※ 주의점
  뷰 페이지에서 변수를 사용할 때는 중괄호를 두개 {{}} 사용하지만
  컨트롤러에서 URL 변수는 하나 {} 만 사용

7.2.3 수정 폼 만들기

============================================

7.3 수정 데이터를 DB에 갱신하기

■ 클라이언트와 서버 간 처리 흐름 4가지 기술

● MVC(Model-View-Controller)
: 서버 역할을 분담해 처리하는 기법

● JPA(Java Persistence API)
: 서버와 db 간 소통에 관여하는 기술

● SQL(Structured Query Language)
: DB 데이터를 관리하는 언어

● HTTP(HyperText Transfer Protocol)
: 데이터를 조고받기 위한 통신 규약

7.3.1 HTTP 메서드

대표적인 메서드
POST: 데이터 생성 요청
GET: 데이터 조회 요청
PATCH(PUT): 데이터 수정 요청
DELETE: 데이터 삭제 요청

=> CRUD

7.3.2 더미 데이터 생성하기

7.3.3 <수정 페이지> 변경하기

7.3.4 수정 데이터 받아오기

7.3.5 DB에 저장하고 결과 페이지로 리다이렉트하기

단계
1. DTO를 엔티티로 변환하기
2. 엔티티를 DB에 저장하기
3. 수정 결과 페이지로 리다이렉트하기

============================================

8장 게시글 삭제하기: Delete

8.1 데이터 삭제 과정

1. 클라이언트가 HTTP 메서드로 특정 게시글의 삭제를 요청
2. 삭제 요청을 받은 컨트롤러는 리파지터리를 통해 DB에 저장된 데이터를 찾아 삭제.
3. 삭제가 완료됬다면 클라이언트를 결과 페이지로 리다이렉트 한다.

■ RedirectAttributes 객체의 addFlashAttribute() 메서드
: 리다이렉트된 페이지에서 사용할 일회성 데이터를 등록 할 수 있다.

============================================

8.2 데이터 삭제하기

8.2.1 Delete 버튼 추가하기

8.2.2 Delete 요청을 받아 데이터 삭제하기

    1. 삭제할 대상 가져오기
    2. 대상 엔티티 삭제하기
    3. 결과 페이지로 리다이렉트하기

8.2.3 삭제 완료 메세지 남기기

■ addFlashAttribute() 메서드
  형식)
  객체명.addFlashAttribute(넘겨_주려는_키_문자열, 넘겨_주려는_값_객체);

8.2.4 SQL 문으로 직접 DB 삭제하기

  DELETE ARTICLE WHERE ID= 3;

8.2.5 최종 정리

============================================

9장 CRUD와 SQL 쿼리 종합

9.1 JPA 로깅 설정하기

■ 로깅(logging)
  시스템이 작동할 때 당시의 상태와 작동 정보를 기록하는것

-> JPA로깅은 resource/application.properties 파일에서 할 수 있다.

■ 로깅 레벨 7단계
  TRACE(레벨1): DEBUG 레벨보다 더 상세한 정보
  DEBUG(레벨2): 응용 프로그램을 디버깅하는 데 필요한 세부 정보
  INFO(레벨3): 응용 프로그램의 순조로운 진행 정보
  WARN(레벨4): 잠재적으로 유해한 상황 정보
  ERROR(레벨5): 응용 프로그램이 수행할 수 이쓴 정도의 오류 정보
  FATAL(레벨6): 응용 프로그램이 중단될 만한 심각한 오류 정보
  OFF(레벨7): 로깅 기능 해제

============================================

9.2 SQL 쿼리 로그 확인하기

9.2.1 데이터 생성 시: INSERT 문

9.2.2 데이터 조회 시: SELECT 문

9.3.3 데이터 수정시: UPDATE 문

9.2.4 데이터 삭제시: DELETE 문

============================================

9.3 기본 SQL 쿼리 작성하기
(생략)
- Create table 테이블명 (
   속성명1 자료형1
   , 속성명2 자료형2
   , PRIMARY KEY(기본키)
   );

- INSERT
  INTO 테이블명 
  ( 컬럼1, 컬럼2)
  VALUES (값, '값);

- SELECT 
  컬럼1, 컬럼2
  FROM 테이블명
  WHERE 조건

- UPDATE
  테이블명
  SET 컬럼 = 값
  WHERE 조건
- DELETE FROM 테이블명
  WHERE 조건

============================================

Part 3 REST API와 테스트 코드 작성하기

10.1 REST API와 JSON의 등장 배경

■ REST API(Representational State Transfer API)
: 서버의 자원을 클라이언트에 구애받지 않고 사용할 수 있게 하는 설계 방식

■ JSON 데이터는 키(KEY) 와 값(VALUE) 로 구성된 정렬되지 않은 속성(Property)의 집합

============================================

10.2 REST API 동작 살펴보기

10.2.1 {JSON} Placeholder 사이트 둘러보기

jsonplaceholder.typicode.com
-> 가짜(fake) API 사용 가능

10.2.2 Talend API tester 설치하기

10.2.3 GET 요청하고 응답받기

- 사이트에서 제공하는 게시글은 총 100개

■ HTTP 상태 코드
1XX(정보) : 요청이 수신돼 처리 중
2XX(성공) : 요청이 성공적으로 처리
3XX(리다이렉션 메세지) : 요청을 완료하려면 추가 행동이 필요
4XX(클라이언트 요청 오류) : 클라이언트의 요청이 잘못돼 서버가 요청을 수행할 수 없음
5XX(서버 응답 오류) : 서버 내부에 에러가 발생해 클라이언트 요청에 대해 적절히 수행하지 못함

10.2.4 POST 요청하고 응답받기

10.2.5 PATCH 요청하고 응답받기

10.2.6 DELETE 요청하고 응답받기

============================================
